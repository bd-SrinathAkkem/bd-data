variables:
  BD_RETRY_COUNT: "2"
  BD_VERSION:
    value: "v1.0.0"
    description: "Black Duck Template Version"
  BD_CREATE_RELEASE:
    value: "false"
    description: "Create a release for the version"
  BD_SYNC_TAGS:
    value: "false"
    description: "Sync tags to latest commit"

# Base configuration for all Black Duck jobs
.bd_semver_base:
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  before_script:
    - apt-get update -qq && apt-get install -y -qq git curl jq bash
    - git config --global user.name "Black Duck CI"
    - git config --global user.email "blackduck-ci@${CI_SERVER_HOST}"
    - git config --global --add safe.directory "$CI_PROJECT_DIR"
    - git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - |
      if [ -z "$CI_JOB_TOKEN" ]; then
        echo "ERROR: CI_JOB_TOKEN is required"
        exit 1
      fi
    - |
      bd_retry_cmd() {
        local cmd="$*"
        local attempt=0
        local max_attempts=${BD_RETRY_COUNT:-2}
      
        until eval "$cmd"; do
          attempt=$((attempt + 1))
          if [ $attempt -ge $max_attempts ]; then
            echo "ERROR: Command failed after $attempt attempts"
            return 1
          fi
          echo "Retrying ($attempt/$max_attempts)..."
          sleep 2
        done
      }

# Stage 1: Validate version format and extract components
bd_validate_version:
  extends: .bd_semver_base
  stage: bd_validate_version
  script:
    - |
      set -e
      
      # Determine version source
      if [ -n "${BD_VERSION:-}" ] && [ "${BD_VERSION}" != "" ]; then
        BD_TAG_NAME="$BD_VERSION"
        echo "Using BD_VERSION: $BD_TAG_NAME"
      elif [ -n "${CI_COMMIT_TAG:-}" ]; then
        BD_TAG_NAME="$CI_COMMIT_TAG"
        echo "Using Git tag: $BD_TAG_NAME"
      else
        echo "ERROR: No BD_VERSION or Git tag provided"
        exit 1
      fi
      
      echo "Validating version: $BD_TAG_NAME"
      
      # Validate semantic version format
      if [[ ! "$BD_TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
        echo "ERROR: Invalid format. Expected: vX.Y.Z or vX.Y.Z-prerelease"
        echo "Received: $BD_TAG_NAME"
        exit 1
      fi
      
      # Parse version components
      BD_VERSION_NO_V="${BD_TAG_NAME#v}"
      BD_BASE_VERSION=$(echo "$BD_VERSION_NO_V" | sed -E 's/[-+].*//')
      IFS='.' read -r BD_MAJOR BD_MINOR BD_PATCH <<< "$BD_BASE_VERSION"
      
      # Determine release type
      if [[ "$BD_TAG_NAME" =~ - ]]; then
        BD_IS_PRERELEASE="true"
      else
        BD_IS_PRERELEASE="false"
      fi
      
      # Validate numeric components
      if ! [[ "$BD_MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$BD_MINOR" =~ ^[0-9]+$ ]] || ! [[ "$BD_PATCH" =~ ^[0-9]+$ ]]; then
        echo "ERROR: Version components must be numeric"
        exit 1
      fi
      
      echo "Version validated: $BD_TAG_NAME (Major: $BD_MAJOR, Minor: $BD_MINOR, Patch: $BD_PATCH, Prerelease: $BD_IS_PRERELEASE)"
      
      # Export variables for subsequent jobs
      {
        echo "BD_TAG_NAME=$BD_TAG_NAME"
        echo "BD_MAJOR=$BD_MAJOR"
        echo "BD_MINOR=$BD_MINOR"
        echo "BD_PATCH=$BD_PATCH"
        echo "BD_IS_PRERELEASE=$BD_IS_PRERELEASE"
      } > bd_version.env
  artifacts:
    reports:
      dotenv: bd_version.env
    expire_in: 1 hour
  rules:
    - if: '$BD_VERSION != null && $BD_VERSION != ""'
      when: always
    - if: '$CI_COMMIT_TAG'
      when: always

# Stage 2: Create Git tag
bd_create_tag:
  extends: .bd_semver_base
  stage: bd_create_tag
  needs:
    - job: bd_validate_version
      artifacts: true
  script:
    - |
      set -e
      
      [ -z "${BD_TAG_NAME:-}" ] && { echo "ERROR: BD_TAG_NAME not available"; exit 1; }
      
      bd_retry_cmd "git fetch --all --tags --prune"
      
      git tag -l | grep -q "^${BD_TAG_NAME}$" && { echo "Tag $BD_TAG_NAME already exists, skipping"; exit 0; }
      
      git tag -a "$BD_TAG_NAME" -m "Release $BD_TAG_NAME"
      bd_retry_cmd "git push origin $BD_TAG_NAME"
      
      echo "Tag created: $BD_TAG_NAME"
  rules:
    - if: '$BD_VERSION != null && $BD_VERSION != ""'
      when: on_success
    - if: '$CI_COMMIT_TAG'
      when: on_success

# Stage 3: Create GitLab release
bd_create_release:
  extends: .bd_semver_base
  stage: bd_create_release
  needs:
    - job: bd_validate_version
      artifacts: true
    - job: bd_create_tag
      optional: true
  script:
    - |
      set -e
      
      [ -z "${BD_TAG_NAME:-}" ] && { echo "ERROR: BD_TAG_NAME not available from validation stage"; exit 1; }
      
      echo "Creating GitLab release: $BD_TAG_NAME"
      
      bd_retry_cmd "git fetch --all --tags --prune"
      
      git tag -l | grep -q "^${BD_TAG_NAME}$" || { echo "ERROR: Git tag $BD_TAG_NAME not found"; exit 1; }
      
      RELEASE_DESCRIPTION="BlackDuck Security Scan $BD_TAG_NAME"
      
      EXISTING_RELEASE_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
        --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases/$BD_TAG_NAME" 2>/dev/null || echo "HTTPSTATUS:404")
      
      HTTP_STATUS=$(echo "$EXISTING_RELEASE_RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
      
      [ "$HTTP_STATUS" = "200" ] && { echo "Release already exists, skipping creation"; exit 0; }
      
      RELEASED_AT=$([ "$BD_IS_PRERELEASE" = "true" ] && echo "null" || echo "\"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"")
      echo $([ "$BD_IS_PRERELEASE" = "true" ] && echo "Creating draft prerelease" || echo "Creating published release")
      
      RELEASE_PAYLOAD=$(jq -nc \
        --arg name "Release $BD_TAG_NAME" \
        --arg tag "$BD_TAG_NAME" \
        --arg desc "$RELEASE_DESCRIPTION" \
        --argjson released "$RELEASED_AT" \
        '{name: $name, tag_name: $tag, description: $desc, released_at: $released}')
      
      echo "Creating new release..."
      RELEASE_RESPONSE=$(bd_retry_cmd "curl -s -w 'HTTPSTATUS:%{http_code}' \
        --request POST \
        --header 'PRIVATE-TOKEN: $CI_JOB_TOKEN' \
        --header 'Content-Type: application/json' \
        --data '$RELEASE_PAYLOAD' \
        'https://${CI_SERVER_HOST}/api/v4/projects/$CI_PROJECT_ID/releases'")
      
      RELEASE_HTTP_STATUS=$(echo "$RELEASE_RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
      
      [ "$RELEASE_HTTP_STATUS" = "200" ] || [ "$RELEASE_HTTP_STATUS" = "201" ] && \
        echo "Release created successfully: $BD_TAG_NAME" || \
        { echo "ERROR: Failed to create release (HTTP $RELEASE_HTTP_STATUS)"; exit 1; }
  rules:
    - if: '$BD_CREATE_RELEASE == "true" && $BD_VERSION != null && $BD_VERSION != ""'
      when: on_success
    - if: '$BD_CREATE_RELEASE == "true" && $CI_COMMIT_TAG'
      when: on_success

# Stage 4: Sync version tags (latest, major)
bd_sync_tags:
  extends: .bd_semver_base
  stage: bd_sync_tags
  needs:
    - job: bd_validate_version
      artifacts: true
    - job: bd_create_tag
      optional: true
    - job: bd_create_release
      optional: true
  script:
    - |
      set -e
      
      [ -z "${BD_TAG_NAME:-}" ] && { echo "ERROR: BD_TAG_NAME not available"; exit 1; }
      echo "Starting tag synchronization for: $BD_TAG_NAME"
      
      [[ "$BD_TAG_NAME" =~ - ]] && { echo "Skipping prerelease"; exit 0; }
      [[ ! "$BD_TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]] && { echo "Invalid format: $BD_TAG_NAME"; exit 0; }
      
      bd_retry_cmd "git fetch --all --tags --prune"
      git tag -l | grep -q "^${BD_TAG_NAME}$" || { echo "ERROR: Tag $BD_TAG_NAME not found"; exit 1; }
      
      BD_TAG_COMMIT=$(git rev-list -n 1 "$BD_TAG_NAME")
      BD_TAG_COMMIT_SHORT=$(git rev-parse --short "$BD_TAG_COMMIT")
      echo "Target commit: $BD_TAG_COMMIT_SHORT"
      
      for TAG in "v$BD_MAJOR" "latest"; do
        echo "Syncing tag: $TAG"
        git tag -d "$TAG" 2>/dev/null || true
        bd_retry_cmd "git push origin :refs/tags/$TAG" || true
        MSG=$([ "$TAG" = "latest" ] && echo "Latest stable release: $BD_TAG_NAME" || echo "Major version tag for $BD_TAG_NAME")
        git tag -a "$TAG" "$BD_TAG_COMMIT" -m "$MSG"
        bd_retry_cmd "git push origin $TAG"
        echo "Tag synced: $TAG -> $BD_TAG_COMMIT_SHORT"
      done
      
      echo "Tag synchronization completed"
  rules:
    - if: '$BD_SYNC_TAGS == "true" && $BD_VERSION != null && $BD_VERSION != ""'
      when: on_success
    - if: '$BD_SYNC_TAGS == "true" && $CI_COMMIT_TAG'
      when: on_success
